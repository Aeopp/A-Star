
# AStar_Algorithm

  **F = 해당 노드에서 목적지 까지의 추론된 비용**
  **G = 출발지에서 해당 노드까지의 현재 상황에서의 최소 비용**
 **H = 해당 노드에서 목적지까지의 근사화해서 추론한 비용**
 
 **여기서 G는 현재 상황 (지금까지 찾아본 오픈리스트에 의한)에서의 해당 노드에서 출발지까지의 비용이며 인접한 노드에서 오는 비용이 더 적을수가 있으므로 언제든지 갱신 (이 때 부모가 바뀜) 할 수 있다.**
 
**F(x) = G(x) + H(x)**
에이스타 알고리즘 프로젝트

https://www.geeksforgeeks.org/a-search-algorithm/

https://itmining.tistory.com/66

##
Key : 1 , 2 , 3
1 = 맨하탄 거리 측정 공식 사용
2 = 대각선 거리 측정 공식 사용
3 = 유클리드 거리법
  

## 프로젝트에 구현한 알고리즘

  

### 맵 구축

1. 타일 맵 정보는 동적 배열

2. 그래프 구성은 동적배열 + 리스트

(동적 배열과 똑같은 크기의 인덱스로 매핑 후 리스트에 갈 수 있는 노드들만 연결

3. 그래프 구축은 최하단아래 참조

  

### 자료구조
1. 최소힙 우선순위큐 (F,G,Index)
  F 로 비교하며 차선으로 H를 사용 .
  
오픈리스트에서 F와 G 의 값은 가변적으로 알고리즘 진행에 따라 계속 갱신되며
전체 소팅은 필요가 없고 항상 현재 상황에서 유리한(F비용이 가장 적은 오픈리스트의 타일)
이 무엇인가만 알아내면 되기 때문에 제일 괜찮은듯

2. 오픈리스트 (해쉬테이블)<타일인덱스,타일정보>
     오픈 노드는 부모와 G,H 를 저장해야 하는 상황 
     부모는 오픈 노드가 최소비용일때 주변 타일들의 해당 오픈노드에서의 경로가 최선인지 갱신하고 해당 오픈노드가 최선이라면 부모를 계속 갱신해줘야 하는 상황이며 해당 오픈노드의 F가 최소비용이 되어 닫힌 목록에 푸시할때
부모를 저장해줘야 하기 때문. H는 불변하므로 저장할 필욘 없으나 휴리스틱 계산 비용이 무거워지면 저장하는게 좋을듯 G는 인접타일에서 경로개선을 위한 비용계산을 할때 이전의 G와 비교하며 최소 경로인지 찾으므로 반드시 저장

3. 닫힌 목록 (해쉬)(인덱스,부모인덱스)
  닫힌 목록은 최소비용 계산이 끝난 타일인지
  식별하기 위한 인덱스와 루프 종료시
  최소 비용의 경로들은 반드시 전부 닫힌 목록에 있으므로 닫힌 목록에서만 검색하면 되며
  그때 사용할 부모인덱스를 저장
  
### 순서도

1. 타일 정보와 그래프 정보를 얻어옴.

2. 좌표를 맵의 타일 인덱스에 매핑 시킨 이후 Start , Goal 인덱스를 구함.

3. 이전의 길찾기 정보가 있으니 큐와 오픈과 클로즈 정보를 날려버린다.

4. 시작 노드를 만든다.
   F,G,H 를 계산하고
   부모를 자기자신으로 설정하고
   오픈리스트와 힙에 푸시한다.
   
**..... 여기서부터 반복**
	   while Heap . IsNotEmpty
		MinF = Heap.pop
		// 최소비용인 노드가 목적지인 상황
		if(MinF.Index == GoalIdx)
		CurrentIdx = GoalIdx;
		Paths  <= 호출자가 필요한 정보;
		// 오픈리스트의 노드들 (여기서는 도착인덱스)의 노드를 검사하기 전이므로
		// 당연히 닫힌 목록에는 없다.
		// 닫힌 목록에 추가해주며 부모인덱스를
		// 오픈목록에서 조회해서 설정해준다.
		Close[GoalIdx] = Open[GoalIdx].parent;
		
		목적지에서 길을 거슬러 올라가는 상황
		while(CurrentIdx!=StartIdx)
		{
	        
			Paths ... 호출자가 필요한 정보로 채워준다. 
			길을 거슬러 올라가기 위해 
			닫힌 목록에서 조회해서 부모를  계속 갱신
			CurrentIdx = Close[CurrentIdx];
		}
		while 종료시 return Paths;

    닫힌 목록에 존재한다면
    해당 인덱스는 검사할 필요가 없다.
	더나은 경로를 발견해서 부모를 갱신해줄때
	G가 더 낮아지고 그로인해 F도 갱신된다.
	해당 상황이면 오픈목록에 있는 비용들의
	정렬상태가 깨진다.
	재정렬할 필요없이 빠른속도의 검색을 위해
	힙을 사용했으며 때문에 큐에 비용을 다시 계산한 Cost 를 푸시해야하고 이때 다시 푸시하면서 큐에는 비용이 다르지만 가르키는 인덱스는 동일한 원소가 생기기 때문에 검사해줘야한다.
클로즈 리스트에 있다면
최소비용으로 갱신하기 전의 노드정보가 들어왔다는 사실을 알 수 있다.
	if Close.find(CurrentIdx) 
			continue ;
	
	for in AdjNode Graph[CurrentIdx]
		if ! IsMove Continue
		갈 수 없는 인접 노드인지 검사
		if Open.IsContain(AdjNode.Index)
		
		.. 오픈 목록에 없으므로 비용 계산을 
		끝마치고 힙과 오픈목록에 푸시한다.
		 
	else if AdjNode.G > GFromParent
	
		오픈 목록에 있으며 해당 노드에서 
		인접노드로의 비용이 더 유리하다면
		부모와 G , F 를 갱신해준다.
		여기서 F 가 달라진 노드가 생기므로
		큐에 해당 인접노드 정보를 푸시한다.

	현재 상황에서 최소비용인 노드의 
	인접 노드까지 푸시하거나 비용을 계산해
	경로를 개선했다.
	해당 노드까지의 경로는 지금 정보가 최소비용이 맞으므로 다시 볼 필요 없게 지우고 푸시
	Open.erase(CurrentIdx)
	Close.Insert(CurrentIdx,Parent)

	   



  
  

## 현재 맵에서 쓰이는 공식들

## 인접 타일 검색하는 공식

### 행이 홀수일 경우

현재 타겟 인덱스를 I 라하고

타일의 X축 기준으로 한 개수를 X 라 하였을때

1. 좌측 상단

I - X

이것을 L 이라고 한다.

2. 우측 상단

L + 1

3. 좌측 하단

I + X

이것을 R이라고 한다.

4. 우측 하단

R + 1

### 행이 짝수일 경우

홀수일 경우와 똑같이 구하되 4가지 경우 전부에 -1을 해야 한다.

  

## 예외처리

1. 인접 타일을 구하기 위한 인덱스를 I 라 한다.

I가 0보다 작거나 599보다 큰경우

존재하지 않는 타일이다.

  

2. 1이 거짓일떄

현재 타일의 좌표를 x1,y1 I인덱스 타일의 좌표를 x2,y2 라 한다.

x y 두 축의 거리가 비정상적으로 나온다면 해당 타일의 해당 인덱스는 존재하지 않는 다.

abs(x1-x2) > DistanceMin || abs(y1-y2) > DistanceMIn 을 만족한다면 해당 인덱스는 인접타일의 인덱스가 아니다.
